# DFA Minimization Tool

This project provides a Python implementation for minimizing Deterministic Finite Automata (DFA). The primary goal of DFA minimization is to reduce the number of states in a given DFA while ensuring that the resulting automaton recognizes the exact same formal language as the original. This process yields a unique minimal DFA (up to state renaming) for any regular language, which is often more efficient for analysis and implementation purposes.

## Algorithmic Approach

The minimization process implemented in this tool follows a standard multi-step algorithm:

1.  **Removal of Unreachable States:** The algorithm first identifies and removes any states that cannot be reached from the initial state by following any sequence of transitions. This is achieved through a graph traversal (like Breadth-First Search or Depth-First Search) starting from the initial state.
2.  **Merging of Indistinguishable States:** After removing unreachable states, the core minimization step involves identifying and merging states that are behaviorally equivalent or "indistinguishable". Two states are considered indistinguishable if, for any input string, starting the machine in either state leads to the same outcome (either both end in an accepting state or both end in a non-accepting state). This implementation uses a partition refinement technique, conceptually similar to Hopcroft's algorithm. It starts by partitioning states into accepting and non-accepting groups and iteratively refines these partitions based on their transitions for each symbol in the alphabet until no further refinement is possible. States remaining in the same partition are indistinguishable and are merged into a single representative state in the minimized DFA.
3.  **Handling of Dead States:** The algorithm may optionally consolidate multiple non-accepting states from which no accepting state can be reached (often called "dead" or "trap" states) into a single canonical dead state, further simplifying the representation.

## Project Structure

### The project consists of the following key files:

*   `main.py`: The main script containing the DFA minimization logic and the command-line interface.
*   `dfa.py`: (User-provided) This file should contain the definition of the input DFA in the specified Python tuple format. An example is provided in `test_dfa.py`.
*   `min.py`: (Output) This file is generated by the script and contains the definition of the minimized DFA.
*   `test_dfa.py`: An example file showing the correct format for defining a DFA. You can copy or rename this file to `dfa.py` to run the example.
*   `environment.yml`: Specifies the Conda environment dependencies.

## Dependencies and Setup

To run this project, you need Python 3.10 or later. It also depends on the `pprintpp` library for enhanced pretty-printing of the output.

You can set up the required environment using Conda:

```bash
conda env create -f environment.yml
conda activate base
```

Alternatively, if you are not using Conda, you can install the necessary package using pip:

```bash
pip install pprintpp python==3.10
```

## Input Format

The input DFA must be defined in a file named `dfa.py` located in the same directory as `main.py`. The file should contain a single Python expression evaluating to a tuple with five elements representing the DFA `(Q, Σ, δ, q₀, F)`:

1.  `Q`: A set of strings representing the states.
2.  `Σ`: A set of characters representing the input alphabet.
3.  `δ`: A dictionary representing the transition function. Keys are states from `Q`. Values are dictionaries where keys are symbols from `Σ` and values are the destination states (strings from `Q`).
4.  `q₀`: A string representing the initial state (must be in `Q`).
5.  `F`: A set of strings representing the final (accepting) states (must be a subset of `Q`).

**Example (`test_dfa.py` content):**

```python
(
    {"A", "B", "C", "D"},  # States (Q)
    {"0", "1"},          # Alphabet (Σ)
    {                   # Transition function (δ)
        "A": {"0": "B", "1": "C"},
        "B": {"0": "A", "1": "D"},
        "C": {"0": "D", "1": "A"},
        "D": {"0": "D", "1": "D"}
    },
    "A",                # Initial state (q₀)
    {"D"}               # Final states (F)
)
```

## Usage

1.  Prepare your input DFA definition in a file named `dfa.py` according to the format described above. You can use the `test_dfa.py` file as a starting point by renaming or copying it.
2.  Navigate to the project directory in your terminal.
3.  Ensure your Python environment (Conda or virtualenv with dependencies installed) is activated.
4.  Run the minimization script:

    ```bash
    python main.py
    ```

5.  The script will read the DFA definition from `dfa.py`, print the original DFA to the console, perform the minimization, and print the resulting minimized DFA. The minimized DFA definition will also be saved to a file named `min.py` in the same directory.

The console output will indicate whether the DFA was reduced or if it was already minimal.

## Output Format

The minimized DFA is written to `min.py` in the same Python tuple format as the input DFA. The states in the minimized DFA might be renamed (typically using representative states from the merged partitions or a canonical name like 'dead' for the dead state).

This tool provides a practical way to apply DFA minimization concepts and obtain an optimized automaton from a given specification.
